import 'dart:math' as math;

import 'package:drift/drift.dart';

import 'migrations.dart';

// This file was generated by `drift_dev schema steps drift_schemas/ lib/database/schema_versions.dart`
// #docregion stepbystep
import 'schema_versions.dart';

// #enddocregion stepbystep

class StepByStep {
  // #docregion stepbystep
  MigrationStrategy get migration {
    return MigrationStrategy(
      onUpgrade: stepByStep(
        from1To2: (m, schema) async {
          // we added the dueDate property in the change from version 1 to
          // version 2
          await m.addColumn(schema.todos, schema.todos.dueDate);
        },
        from2To3: (m, schema) async {
          // we added the priority property in the change from version 1 or 2
          // to version 3
          await m.addColumn(schema.todos, schema.todos.priority);
        },
      ),
    );
  }
  // #enddocregion stepbystep
}

extension StepByStep2 on GeneratedDatabase {
  MigrationStrategy get migration {
    return MigrationStrategy(
      // #docregion stepbystep2
      onUpgrade: (m, from, to) async {
        // Disable foreign keys temporarily
        await customStatement('PRAGMA foreign_keys = OFF');

        await m.runMigrationSteps(
          from: from,
          to: to,
          steps: migrationSteps(
            from1To2: (m, schema) async {
              // we added the dueDate property in the change from version 1 to
              // version 2
              await m.addColumn(schema.todos, schema.todos.dueDate);
            },
            from2To3: (m, schema) async {
              // we added the priority property in the change from version 1 or 2
              // to version 3
              await m.addColumn(schema.todos, schema.todos.priority);
            },
          ),
        );

        if (kDebugMode) {
          // Fail if the migration broke foreign keys
          final wrongForeignKeys =
              await customSelect('PRAGMA foreign_key_check').get();
          assert(wrongForeignKeys.isEmpty,
              wrongForeignKeys.map((e) => e.data).toList());
        }
        // Re-enable foreign keys
        await customStatement('PRAGMA foreign_keys = ON;');
      },
      // #enddocregion stepbystep2
    );
  }
}

extension StepByStep3 on MyDatabase {
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        await m.createAll();
      },
      // #docregion stepbystep3
      onUpgrade: (m, from, to) async {
        // Run migration steps without foreign keys and re-enable them later
        // (https://drift.simonbinder.eu/docs/advanced-features/migrations/#tips)
        await customStatement('PRAGMA foreign_keys = OFF');

        // Manually running migrations up to schema version 2, after which we've
        // enabled step-by-step migrations.
        if (from < 2) {
          // we added the dueDate property in the change from version 1 to
          // version 2 - before switching to step-by-step migrations.
          await m.addColumn(todos, todos.dueDate);
        }

        // At this point, we should be migrated to schema 3. For future schema
        // changes, we will "start" at schema 3.
        await m.runMigrationSteps(
          from: math.max(2, from),
          to: to,
          // ignore: missing_required_argument
          steps: migrationSteps(
            from2To3: (m, schema) async {
              // we added the priority property in the change from version 1 or
              // 2 to version 3
              await m.addColumn(schema.todos, schema.todos.priority);
            },
          ),
        );

        if (kDebugMode) {
          // Fail if the migration broke foreign keys
          final wrongForeignKeys =
              await customSelect('PRAGMA foreign_key_check').get();
          assert(wrongForeignKeys.isEmpty,
              '${wrongForeignKeys.map((e) => e.data)}');
        }

        await customStatement('PRAGMA foreign_keys = ON;');
      },
      // #enddocregion stepbystep3
    );
  }
}

extension StepByStep4 on GeneratedDatabase {
  MigrationStrategy get migration {
    return MigrationStrategy(
        onUpgrade: stepByStep(
      from1To2: (m, schema) async {},
      from2To3: (m, schema) async {
        // #docregion drop_column
        await m.dropColumn(schema.todos, schema.todos.dueDate.name);
        // #enddocregion drop_column
        // #docregion drop_table
        await m.drop(schema.todos);
        // #enddocregion drop_table
        // #docregion add_column
        await m.addColumn(schema.todos, schema.todos.dueDate);
        // #enddocregion add_column
        // #docregion add_table_and_index
        await m.create(schema.todos);
        await m.create(schema.todosTitle);
        // #enddocregion add_table_and_index
        // #docregion rename_column
        await m.renameColumn(schema.todos, "date_due", schema.todos.dueDate);
        // #enddocregion rename_column
        // #docregion rename_table
        await m.renameTable(schema.todos, "all_the_todos");
        // #enddocregion rename_table
        // #docregion add_any_column
        await m.alterTable(
            TableMigration(schema.todos, newColumns: [schema.todos.dueDate]));
        // #enddocregion add_any_column
        // #docregion remove_any_column
        await m.alterTable(TableMigration(schema.todos));
        // #enddocregion remove_any_column
        // #docregion change_type
        // The priority column was previously an integer, but we want to store
        // it as a string now.
        await m.alterTable(TableMigration(schema.todos, columnTransformer: {
          schema.todos.priority: schema.todos.priority.cast<String>()
        }));
        // #enddocregion change_type
      },
    ));
  }
}

class Books extends Table {
  // #docregion drop_primary_key
  // This column is a primary key, it cannot be removed
  IntColumn get id => integer().autoIncrement()();
  // #enddocregion drop_primary_key

  // #docregion drop_column_with_expression
  /// Before we can delete the alternative title column, we must first
  /// remove the check constraints that reference it.
  TextColumn get title => text()();

  // This check constraint must be removed
  TextColumn get alternativeTitle =>
      text().check(title.equalsExp(title).not())();

  @override
  // And this one as well
  List<String> get customConstraints => ['CHECK (LENGTH(title) < 10)'];

  // This generated columns which depends on the alternative title column must be removed/modifed
  TextColumn get fullTitle =>
      text().generatedAs(title + Constant(" ") + alternativeTitle)();
  // #enddocregion drop_column_with_expression

  // #docregion add_required_column
  // This column is required, it cannot be added
  IntColumn get pageCount => integer()();

  // The default value can not be added with `clientDefault`
  IntColumn get pageCountClientDefault => integer().clientDefault(() => 0)();
  // #enddocregion add_required_column

  // #docregion add_column_with_unique
  // This column has a unique constraint, it cannot be added
  TextColumn get username => text().unique()();
  // #enddocregion add_column_with_unique

  // #docregion add_generated_column
  // A generated column which stores its value in the database cannot be added
  TextColumn get titleWithAlternative => text()
      .generatedAs(title + Constant(" ") + alternativeTitle, stored: true)();

  // However, a generated column which is not stored in the database can be added
  TextColumn get titleWithAlternativeNotStored => text()
      .generatedAs(title + Constant(" ") + alternativeTitle, stored: false)();
  // #enddocregion add_generated_column

  // #docregion add_column_with_expression
  // OK
  IntColumn get age => integer().withDefault(Constant(18))();

  // Not OK
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();

  // Not OK -
  IntColumn get age2 => integer().withDefault(Constant(18) + Constant(18))();
  // #enddocregion add_column_with_expression
// #docregion fake_rename_column
  // No migration needed
  // TextColumn get authorName => text()();
  TextColumn get name => text().named('author_name')();
// #enddocregion fake_rename_column
}

// #docregion drop_column_with_index
@TableIndex(name: "authors_age", columns: {#age})
class Authors extends Table {
  IntColumn get id => integer().autoIncrement()();

  // This column has an index, it cannot be removed without removing the index first
  IntColumn get age => integer().nullable()();
// #enddocregion drop_column_with_index

  // #docregion drop_column_with_unique
  // This column has a unique constraint, it cannot be removed
  TextColumn get name => text().unique()();
  // #enddocregion drop_column_with_unique
// #docregion drop_column_with_index
}
// #enddocregion drop_column_with_index
